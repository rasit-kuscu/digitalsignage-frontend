{"version":3,"file":"fluent-assign.js","sourceRoot":"","sources":["fluent-assign.ts"],"names":[],"mappings":"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","sourcesContent":["import {extend, arrayUnion} from './utils';\nconst PRIVATE_PREFIX = '$$';\nconst RESERVED_REGEX = /^(\\$\\$).*/;\n\nfunction validateMethodName(name: string) {\n    if (!name) {\n        throw new Error(`Illegal method name. Empty method name is not allowed`);\n    } else if (name in this) {\n        throw new Error(`A member name '${name}' already defined.`);\n    }\n}\n\n/**\n * Returns a list of assigned property names (non private)\n * @param subject\n * @returns {string[]}\n */\nfunction getAssignedPropertyNames(subject: any): string[] {\n    return Object.getOwnPropertyNames(subject)\n        .filter(name => RESERVED_REGEX.test(name))\n        .map(name => name.substr(2));\n}\n\nexport function privateKey(name: string): string {\n    return PRIVATE_PREFIX + name;\n}\n\nfunction objectDefinePropertyValue(obj: any, propertyName, value: (value: any) => void): void {\n    Object.defineProperty(obj, propertyName, <any>{\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value\n    });\n}\n\n/**\n * Given a FluentAssign instance, apply all of the supplied default values so calling\n * instance.toJSON will return those values (does not create a setter function)\n * @param instance\n * @param defaultValues\n */\nfunction applyDefaultValues(instance: any, defaultValues: Object): void {\n    Object.getOwnPropertyNames(defaultValues)\n        .forEach(name => (<any>instance)[privateKey(name)] = (<any>defaultValues)[name]);\n}\n\n/**\n * Create a function for setting a value for a property on a given object.\n * @param obj The object to apply the key & setter on.\n * @param propertyName The name of the property on the object\n * @param writeOnce If true will allow writing once (default: false)\n *\n * Example:\n * let obj = new FluentAssign<any>;\n * setAssignMethod(obj, 'myProp');\n * obj.myProp('someValue');\n * const result = obj.toJSON();\n * console.log(result); //{ myProp: 'someValue' }\n *\n *\n * let obj = new FluentAssign<any>;\n * setAssignMethod(obj, 'myProp', true); // applying writeOnce\n * obj.myProp('someValue');\n * obj.myProp('someValue'); // ERROR: Overriding config property 'myProp' is not allowed.\n */\nexport function setAssignMethod<T>(obj: T, propertyName: string, writeOnce: boolean = false): void {\n    validateMethodName.call(obj, propertyName);\n\n    const key = privateKey(propertyName);\n    objectDefinePropertyValue(obj, propertyName, (value: any) => {\n        if (writeOnce && this.hasOwnProperty(key)) {\n            throw new Error(`Overriding config property '${propertyName}' is not allowed.`);\n        }\n        obj[key] = value;\n        return obj;\n    });\n}\n\n/**\n * Create a function for setting a value that is an alias to an other setter function.\n * @param obj The object to apply the key & setter on.\n * @param propertyName The name of the property on the object\n * @param srcPropertyName The name of the property on the object this alias points to\n * @param hard If true, will set a readonly property on the object that returns \n *        the value of the source property. Default: false\n *        \n * Example:\n * let obj = new FluentAssign<any> ;\n * setAssignMethod(obj, 'myProp'); \n * setAssignAlias(obj, 'myPropAlias', 'myProp');\n * obj.myPropAlias('someValue');\n * const result = obj.toJSON();\n * console.log(result); //{ myProp: 'someValue' }\n * result.myPropAlias // undefined\n * \n *\n * let obj = new FluentAssign<any> ;\n * setAssignMethod(obj, 'myProp');\n * setAssignAlias(obj, 'myPropAlias', 'myProp', true); // setting a hard alias.\n * obj.myPropAlias('someValue');\n * const result = obj.toJSON();\n * console.log(result); //{ myProp: 'someValue' }\n * result.myPropAlias // someValue\n */\nexport function setAssignAlias<T>(obj: T, propertyName: string, \n                                  srcPropertyName: string, \n                                  hard: boolean = false): void {\n    validateMethodName.call(obj, propertyName);\n    \n    objectDefinePropertyValue(obj, propertyName, (value: any) => {\n        obj[srcPropertyName](value);\n        return obj;\n    });\n    \n    if (hard === true) {\n        const key = privateKey(propertyName), \n              srcKey = privateKey(srcPropertyName);\n\n        Object.defineProperty(obj, key, <any>{\n            configurable: false,\n            enumerable: false,\n            get: () => obj[srcKey]\n        });\n    }\n}\n\n/**\n * Describes a fluent assign method.\n * A function that gets a value and returns the instance it works on.\n */\nexport interface FluentAssignMethod<T, Z> {\n    //TODO: Setting 'this' instead of Z does not work, this=ConfigSetter here...\n    (value: T): Z;\n}\n\n\nexport interface IFluentAssignFactory<Z> {\n    fluentAssign: Z;\n    setMethod(name: string, defaultValue?: any): IFluentAssignFactory<Z>;\n}\n\n/**\n * Represent a fluent API factory wrapper for defining FluentAssign instances.\n */\nexport class FluentAssignFactory<T> {\n    private _fluentAssign: FluentAssign<T>;\n\n    constructor(fluentAssign?: FluentAssign<T>) {\n        this._fluentAssign =\n            fluentAssign instanceof FluentAssign ? fluentAssign : <any>new FluentAssign();\n    }\n\n    /**\n     * Create a setter method on the FluentAssign instance.\n     * @param name The name of the setter function.\n     * @param defaultValue If set (not undefined) set's the value on the instance immediately.\n     * @returns {FluentAssignFactory}\n     */\n    setMethod(name: string, defaultValue: any = undefined): FluentAssignFactory<T> {\n        setAssignMethod(this._fluentAssign, name);\n        if (defaultValue !== undefined) {\n            (<any>this._fluentAssign)[name](defaultValue);\n        }\n        return this;\n    }\n\n    /**\n     * The FluentAssign instance.\n     * @returns {FluentAssign<T>}\n     */\n    get fluentAssign(): FluentAssign<T> {\n        return this._fluentAssign;\n    }\n}\n\n\n\n/**\n * Represent an object where every property is a function representing an assignment function.\n * Calling each function with a value will assign the value to the object and return the object.\n * Calling 'toJSON' returns an object with the same properties but this time representing the\n * assigned values.\n *\n * This allows setting an object in a fluent API manner.\n * Example:\n let fluent = new FluentAssign<any>(undefined, ['some', 'went']);\n fluent.some('thing').went('wrong').toJSON();\n // { some: 'thing', went: 'wrong' }\n */\nexport class FluentAssign<T> {\n    private __fluent$base__: new () => T;\n\n    /**\n     * Returns a FluentAssignFactory<FluentAssign<T>> ready to define a FluentAssign type.\n     * @param defaultValues An object representing default values for the instance.\n     * @param initialSetters A list of initial setters for the instance.\n     * @returns {FluentAssignFactory<T>}\n     */\n    static compose<T>(defaultValues: T = undefined,\n                      initialSetters: string[] = undefined): FluentAssignFactory<T> {\n\n        return <any>FluentAssign.composeWith<FluentAssign<T>>(\n            new FluentAssign<T>(defaultValues, initialSetters));\n    }\n\n    /**\n     * Returns a FluentAssignFactory<Z> where Z is an instance of FluentAssign<?> or a derived\n     * class of it.\n     * @param fluentAssign An instance of FluentAssign<?> or a derived class of FluentAssign<?>.\n     * @returns {any}\n     */\n    static composeWith<Z>(fluentAssign: Z): IFluentAssignFactory<Z> {\n        return <any>new FluentAssignFactory<any>(<any>fluentAssign);\n    }\n    \n    /**\n     *\n     * @param defaultValues An object representing default values for the underlying object.\n     * @param initialSetters A list of initial setters for this FluentAssign.\n     * @param baseType the class/type to create a new base. optional, {} is used if not supplied.\n     */\n    constructor(defaultValues: T | T[] = undefined,\n                initialSetters: string[] = undefined,\n                baseType: new () => T = undefined) {\n        if (Array.isArray(defaultValues)) {\n            defaultValues.forEach(d => applyDefaultValues(this, d));\n        } else if (defaultValues) {\n            applyDefaultValues(this, defaultValues);\n        }\n        \n        if (Array.isArray(initialSetters)) {\n            \n            initialSetters.forEach(name => setAssignMethod(this, name));\n        }\n\n        if (baseType) {\n            this.__fluent$base__ = baseType;\n        }\n    }\n\n    toJSON(): T {\n        return getAssignedPropertyNames(this)\n            .reduce((obj: T, name: string) => {\n                const key = privateKey(name);\n                // re-define property descriptors (we dont want their value)\n                let propDesc = Object.getOwnPropertyDescriptor(this, key);\n                if (propDesc) {\n                    Object.defineProperty(obj, name, propDesc);\n                } else {\n                    (<any>obj)[name] = (<any>this)[key];\n                }\n                return obj;\n            }, this.__fluent$base__ ? new this.__fluent$base__() : <any>{});\n    }\n}\n"]}